Index: er9x/drivers.cpp
===================================================================
--- er9x/drivers.cpp	(revision 651)
+++ er9x/drivers.cpp	(working copy)
@@ -17,6 +17,7 @@
 
 #include "er9x.h"
 
+#ifndef SIMU
 #include "avr/interrupt.h"
 
 ///opt/cross/avr/include/avr/eeprom.h
@@ -47,12 +48,13 @@
 void eeWriteBlockCmp(const void *i_pointer_ram, void *i_pointer_eeprom, size_t size)
 {
   const char* pointer_ram = (const char*)i_pointer_ram;
-  uint16_t    pointer_eeprom = (uint16_t)i_pointer_eeprom;
+  uint16_t    pointer_eeprom = (uint16_t)(uint64_t)i_pointer_eeprom;
   while(size){
     eeprom_write_byte_cmp(*pointer_ram++,pointer_eeprom++);
     size--;
   }
 }
+#endif
 
 //inline uint16_t anaIn(uint8_t chan)
 //{
Index: er9x/er9x.cpp
===================================================================
--- er9x/er9x.cpp	(revision 651)
+++ er9x/er9x.cpp	(working copy)
@@ -390,8 +390,10 @@
 
         clearKeyEvents();
 
+#ifndef SIMU
         for(uint8_t i=0; i<32; i++)
             getADC_filt(); // init ADC array
+#endif
 
 #define INAC_DEVISOR 256   // Issue 206 - bypass splash screen with stick movement
         uint16_t inacSum = 0;
@@ -401,7 +403,11 @@
         uint16_t tgtime = get_tmr10ms() + SPLASH_TIMEOUT;  
         while(tgtime != get_tmr10ms())
         {
+#ifdef SIMU
+            if (!main_thread_running) return;
+#else
             getADC_filt();
+#endif
             uint16_t tsum = 0;
             for(uint8_t i=0; i<4; i++)
                tsum += anaIn(i)/INAC_DEVISOR;
@@ -447,7 +453,10 @@
 
   int16_t lowLim = THRCHK_DEADBAND + g_eeGeneral.calibMid[thrchn] - g_eeGeneral.calibSpanNeg[thrchn];// + g_eeGeneral.calibSpanNeg[thrchn]/8;
 
+#ifndef SIMU
   getADC_single();   // if thr is down - do not display warning at all
+#endif
+
   int16_t v      = anaIn(thrchn);
   if((v<=lowLim) || (keyDown()))
   {
@@ -460,7 +469,11 @@
 	//loop until all switches are reset
   while (1)
   {
+#ifdef SIMU
+      if (!main_thread_running) return;
+#else
       getADC_single();
+#endif
       int16_t v      = anaIn(thrchn);
       if((v<=lowLim) || (keyDown()))
       {
@@ -499,6 +512,10 @@
 	//loop until all switches are reset
   while (1)
   {
+#ifdef SIMU
+    if (!main_thread_running) return;
+#endif
+
     uint8_t i;
     for(i=SW_BASE; i<SW_Trainer; i++)
     {
@@ -583,6 +600,9 @@
     clearKeyEvents();
     while(1)
     {
+#ifdef SIMU
+    if (!main_thread_running) return;
+#endif
         if(keyDown())
         {
             return;  //wait for key release
@@ -928,7 +948,10 @@
 int16_t g_ppmIns[8];
 uint8_t ppmInState = 0; //0=unsync 1..8= wait for value i-1
 
+#ifndef SIMU
 #include <avr/interrupt.h>
+#endif
+
 //#include <avr/wdt.h>
 
 //class AutoLock
@@ -948,6 +971,7 @@
 //#define STARTADCONV (ADCSRA  = (1<<ADEN) | (1<<ADPS0) | (1<<ADPS1) | (1<<ADPS2) | (1<<ADSC) | (1 << ADIE))
 int16_t BandGap = 240 ;
 
+#ifndef SIMU
 static uint16_t s_anaFilt[8];
 uint16_t anaIn(uint8_t chan)
 {
@@ -959,7 +983,6 @@
   return  *p;
 }
 
-
 #define ADC_VREF_TYPE 0x40
 void getADC_filt()
 {
@@ -1063,9 +1086,11 @@
   getADC_osmp,
   getADC_filt
   };
+#endif
 
 volatile uint8_t g_tmr16KHz;
 
+#ifndef SIMU
 ISR(TIMER0_OVF_vect, ISR_NOBLOCK) //continuous timer 16ms (16MHz/1024)
 {
   g_tmr16KHz++;
@@ -1322,4 +1347,4 @@
       if ( t0 > g_timeMain ) g_timeMain = t0 ;
 }
 
-
+#endif
Index: er9x/er9x.h
===================================================================
--- er9x/er9x.h	(revision 651)
+++ er9x/er9x.h	(working copy)
@@ -23,6 +23,9 @@
 
 ///opt/cross/avr/include/avr/pgmspace.h
 #include <stddef.h>
+
+#ifndef SIMU
+
 #include <avr/io.h>
 #define assert(x)
 //disable whole pgmspace functionality for all avr-gcc because
@@ -53,6 +56,8 @@
 
 //#define eeprom_write_block eeWriteBlockCmp
 
+#endif
+
 #include "file.h"
 //
 //                  elev                        thr
Index: er9x/file.cpp
===================================================================
--- er9x/file.cpp	(revision 651)
+++ er9x/file.cpp	(working copy)
@@ -39,19 +39,20 @@
 #define BLOCKS   (EESIZE/BS)
 
 #define EEFS_VERS 4
-struct DirEnt{
+PACK(struct DirEnt{
   uint8_t  startBlk;
   uint16_t size:12;
   uint16_t typ:4;
-}__attribute__((packed));
+});
+
 #define MAXFILES (1+MAX_MODELS+3)
-struct EeFs{
+PACK(struct EeFs{
   uint8_t  version;
   uint8_t  mySize;
   uint8_t  freeList;
   uint8_t  bs;
   DirEnt   files[MAXFILES];
-}__attribute__((packed)) eeFs;
+}) eeFs;
 
 
 static uint8_t EeFsRead(uint8_t blk,uint8_t ofs){
@@ -165,10 +166,6 @@
 }
 void EeFsFormat()
 {
-  if(sizeof(eeFs) != RESV){
-    extern void eeprom_RESV_mismatch();
-    eeprom_RESV_mismatch();
-  }
   memset(&eeFs,0, sizeof(eeFs));
   eeFs.version  = EEFS_VERS;
   eeFs.mySize   = sizeof(eeFs);
Index: er9x/file.h
===================================================================
--- er9x/file.h	(revision 651)
+++ er9x/file.h	(working copy)
@@ -75,7 +75,7 @@
   ///read from opened file and decode rlc-coded data
   uint16_t readRlc(uint8_t*buf,uint16_t i_len);
   ///deliver current errno, this is reset in open
-  uint8_t errno(){return m_err;}
+  uint8_t write_errno(){return m_err;}
 };
 
 #endif
Index: er9x/lcd.cpp
===================================================================
--- er9x/lcd.cpp	(revision 651)
+++ er9x/lcd.cpp	(working copy)
@@ -16,7 +16,12 @@
 
 #include "er9x.h"
 
+#ifdef SIMU
+bool lcd_refresh = true;
+uint8_t lcd_buf[DISPLAY_W*DISPLAY_H/8];
+#endif
 
+
 uint8_t displayBuf[DISPLAY_W*DISPLAY_H/8];
 #define DISPLAY_END (displayBuf+sizeof(displayBuf))
 #include "font.lbm"
@@ -427,6 +432,11 @@
 
 void refreshDiplay()
 {
+#ifdef SIMU
+  memcpy(lcd_buf, displayBuf, sizeof(displayBuf));
+  lcd_refresh = true;
+#else
+
   uint8_t *p=displayBuf;
   for(uint8_t y=0; y < 8; y++) {
     lcdSendCtl(0x04);
@@ -456,4 +466,5 @@
     PORTC_LCD_CTRL |=  (1<<OUT_C_LCD_A0);
     PORTC_LCD_CTRL |=  (1<<OUT_C_LCD_CS1);
   }
+#endif
 }
Index: er9x/menus.cpp
===================================================================
--- er9x/menus.cpp	(revision 651)
+++ er9x/menus.cpp	(working copy)
@@ -565,7 +565,7 @@
         v += g_model.limitData[i].revert ?
                     (zero_chans512_before[i] - zero_chans512_after[i]) :
                     (zero_chans512_after[i] - zero_chans512_before[i]);
-        g_model.limitData[i].offset = max(min(v,1000),-1000); // make sure the offset doesn't go haywire
+        g_model.limitData[i].offset = max(min(v,(int16_t)1000),(int16_t)-1000); // make sure the offset doesn't go haywire
     }
 
     // For this operation, keep using the 'MASTER' trims
@@ -845,7 +845,7 @@
 
         //write mix names here
         lcd_outdezNAtt(3*FW, y, k+1, (sub==k ? INVERS : 0) + LEADING0,2);
-        lcd_putsAtt(  4*FW, y, (const prog_char*)pgm_read_word(&n_Templates[k]), (s_noHi ? 0 : (sub==k ? INVERS  : 0)));
+        lcd_putsAtt(  4*FW, y, n_Templates[k], (s_noHi ? 0 : (sub==k ? INVERS  : 0)));
         y+=FH;
     }
 
@@ -3018,8 +3018,9 @@
     lcd_outdezAtt(14*FW , 4*FH, (g_timeMain*100)/16 ,PREC2);
 
     lcd_puts_P( 0*FW,  5*FH, PSTR("Stack          b"));
+#ifndef SIMU
     lcd_outhex4( 10*FW+3, 5*FH, stack_free() ) ;
-
+#endif
     lcd_puts_P( 3*FW,  7*FH, PSTR("[MENU] to refresh"));
 }
 
@@ -3667,10 +3668,14 @@
             //Normalization  [0..2048] ->   [-1024..1024]
 
             int16_t v = anaIn(i);
+
+#ifndef SIMU
             v -= g_eeGeneral.calibMid[i];
             v  =  v * (int32_t)RESX /  (max((int16_t)100,(v>0 ?
                                                               g_eeGeneral.calibSpanPos[i] :
                                                               g_eeGeneral.calibSpanNeg[i])));
+#endif
+
             if(v <= -RESX) v = -RESX;
             if(v >=  RESX) v =  RESX;
 	  				if ( g_eeGeneral.throttleReversed )
Index: er9x/menus.h
===================================================================
--- er9x/menus.h	(revision 651)
+++ er9x/menus.h	(working copy)
@@ -77,10 +77,10 @@
 #define TITLEP(pstr) lcd_putsAtt(0,0,pstr,INVERS)
 #define TITLE(str)   TITLEP(PSTR(str))
 
-#define MENU(title, tab, menu, lines_count, lines...) \
+#define MENU(title, tab, menu, lines_count, ...) \
 TITLE(title); \
 static MState2 mstate2; \
-static prog_uint8_t APM mstate_tab[] = lines; \
+static prog_uint8_t APM mstate_tab[] = __VA_ARGS__; \
 mstate2.check(event,menu,tab,DIM(tab),mstate_tab,DIM(mstate_tab)-1,lines_count-1)
 
 #define SIMPLE_MENU(title, tab, menu, lines_count) \
@@ -88,10 +88,10 @@
 static MState2 mstate2; \
 mstate2.check_simple(event,menu,tab,DIM(tab),lines_count-1)
 
-#define SUBMENU(title, lines_count, lines...) \
+#define SUBMENU(title, lines_count, ...) \
 TITLE(title); \
 static MState2 mstate2; \
-static prog_uint8_t APM mstate_tab[] = lines; \
+static prog_uint8_t APM mstate_tab[] = __VA_ARGS__; \
 mstate2.check(event,0,NULL,0,mstate_tab,DIM(mstate_tab)-1,lines_count-1)
 
 #define SIMPLE_SUBMENU_NOTITLE(lines_count) \
Index: er9x/myeeprom.h
===================================================================
--- er9x/myeeprom.h	(revision 651)
+++ er9x/myeeprom.h	(working copy)
@@ -59,19 +59,23 @@
 #define GENERAL_OWNER_NAME_LEN 10
 #define MODEL_NAME_LEN         10
 
-typedef struct t_TrainerMix {
+#ifndef PACK
+#define PACK( __Declaration__ ) __Declaration__ __attribute__((__packed__))
+#endif
+
+PACK(typedef struct t_TrainerMix {
   uint8_t srcChn:3; //0-7 = ch1-8
   int8_t  swtch:5;
   int8_t  studWeight:6;
   uint8_t mode:2;   //off,add-mode,subst-mode
-} __attribute__((packed)) TrainerMix; //
+}) TrainerMix; //
  
-typedef struct t_TrainerData {
+PACK(typedef struct t_TrainerData {
   int16_t        calib[4];
   TrainerMix     mix[4];
-} __attribute__((packed)) TrainerData;
+}) TrainerData;
 
-typedef struct t_EEGeneral {
+PACK(typedef struct t_EEGeneral {
   uint8_t   myVers;
   int16_t   calibMid[7];
   int16_t   calibSpanNeg[7];
@@ -115,7 +119,7 @@
   uint8_t   res[1];
 //  uint8_t	FRSkyRed;  //mike please check these are correct
   char      ownerName[GENERAL_OWNER_NAME_LEN];
-} __attribute__((packed)) EEGeneral;
+}) EEGeneral;
 
 
 
@@ -124,25 +128,25 @@
 //eeprom modelspec
 //expo[3][2][2] //[Norm/Dr][expo/weight][R/L]
 
-typedef struct t_ExpoData {
+PACK(typedef struct t_ExpoData {
   int8_t  expo[3][2][2];
   int8_t  drSw1;
   int8_t  drSw2;
-} __attribute__((packed)) ExpoData;
+}) ExpoData;
 
 
-typedef struct t_LimitData {
+PACK(typedef struct t_LimitData {
   int8_t  min;
   int8_t  max;
   bool    revert;
   int16_t  offset;
-} __attribute__((packed)) LimitData;
+}) LimitData;
 
 #define MLTPX_ADD  0
 #define MLTPX_MUL  1
 #define MLTPX_REP  2
 
-typedef struct t_MixData {
+PACK(typedef struct t_MixData {
   uint8_t destCh;            //        1..NUM_CHNOUT
   uint8_t srcRaw;            //
   int8_t  weight;
@@ -159,33 +163,33 @@
   uint8_t mixres:1;
   int8_t  sOffset;
   int8_t  res;
-} __attribute__((packed)) MixData;
+}) MixData;
 
 
-typedef struct t_CSwData { // Custom Switches data
+PACK(typedef struct t_CSwData { // Custom Switches data
   int8_t  v1; //input
   int8_t  v2; //offset
   uint8_t func;
-} __attribute__((packed)) CSwData;
+}) CSwData;
 
-typedef struct t_SafetySwData { // Custom Switches data
+PACK(typedef struct t_SafetySwData { // Custom Switches data
   int8_t  swtch;
   int8_t  val;
-} __attribute__((packed)) SafetySwData;
+}) SafetySwData;
 
-typedef struct t_FrSkyChannelData {
+PACK(typedef struct t_FrSkyChannelData {
   uint8_t   ratio;                // 0.0 means not used, 0.1V steps EG. 6.6 Volts = 66. 25.1V = 251, etc.
   uint8_t   alarms_value[2];      // 0.1V steps EG. 6.6 Volts = 66. 25.1V = 251, etc.
   uint8_t   alarms_level:4;
   uint8_t   alarms_greater:2;     // 0=LT(<), 1=GT(>)
   uint8_t   type:2;               // 0=volts, 1=raw, 2=volts*2, 3=Amps
-} __attribute__((packed)) FrSkyChannelData;
+}) FrSkyChannelData;
 
-typedef struct t_FrSkyData {
+PACK(typedef struct t_FrSkyData {
   FrSkyChannelData channels[2];
-} __attribute__((packed)) FrSkyData;
+}) FrSkyData;
 
-typedef struct t_ModelData {
+PACK(typedef struct t_ModelData {
   char      name[MODEL_NAME_LEN];             // 10 must be first for eeLoadModelName
   uint8_t   mdVers;
   int8_t    tmrMode;              // timer trigger source -> off, abs, stk, stk%, sw/!sw, !m_sw/!m_sw
@@ -224,7 +228,7 @@
   uint8_t   res3[2];
   SafetySwData  safetySw[NUM_CHNOUT];
   FrSkyData frsky;
-} __attribute__((packed)) ModelData;
+}) ModelData;
 
 #define TOTAL_EEPROM_USAGE (sizeof(ModelData)*MAX_MODELS + sizeof(EEGeneral))
 
Index: er9x/pers.cpp
===================================================================
--- er9x/pers.cpp	(revision 651)
+++ er9x/pers.cpp	(working copy)
@@ -47,7 +47,7 @@
     g_eeGeneral.calibSpanNeg[i] = 0x180;
     g_eeGeneral.calibSpanPos[i] = 0x180;
   }
-  strcpy_P(g_model.name,PSTR("ME        "));
+  // strcpy_P(g_model.name,PSTR("ME        "));
   int16_t sum=0;
   for(int i=0; i<12;i++) sum+=g_eeGeneral.calibMid[i];
   g_eeGeneral.chkSum = sum;
@@ -78,7 +78,7 @@
 void modelDefault(uint8_t id)
 {
   memset(&g_model, 0, sizeof(ModelData));
-  strcpy_P(g_model.name,PSTR("MODEL     "));
+  memcpy(g_model.name,PSTR("MODEL     "),10);
   g_model.name[5]='0'+(id+1)/10;
   g_model.name[6]='0'+(id+1)%10;
   g_model.mdVers = MDVERS;
@@ -159,7 +159,7 @@
   while((l=theFile.read(buf,15)))
   {
     theFile2.write(buf,l);
-//    if(theFile.errno()==ERR_TMO)
+//    if(theFile.write_errno()==ERR_TMO)
 //    {
 //        //wait for 10ms and try again
 //        uint16_t tgtime = get_tmr10ms() + 100;
@@ -247,7 +247,7 @@
     {
       EFile::swap(FILE_GENERAL,FILE_TMP);
     }else{
-      if(theWriteFile.errno()==ERR_TMO){
+      if(theWriteFile.write_errno()==ERR_TMO){
         s_eeDirtyMsk |= EE_GENERAL; //try again
         s_eeDirtyTime10ms = get_tmr10ms() - WRITE_DELAY_10MS;
       }else{
@@ -262,7 +262,7 @@
     {
       EFile::swap(FILE_MODEL(g_eeGeneral.currModel),FILE_TMP);
     }else{
-      if(theWriteFile.errno()==ERR_TMO){
+      if(theWriteFile.write_errno()==ERR_TMO){
         s_eeDirtyMsk |= EE_MODEL; //try again
         if ( msk & EE_TRIM )
         {
Index: er9x/simpgmspace.cpp
===================================================================
--- er9x/simpgmspace.cpp	(revision 0)
+++ er9x/simpgmspace.cpp	(revision 0)
@@ -0,0 +1,139 @@
+/*
+ * Authors (alphabetical order)
+ * - Bertrand Songis <bsongis@gmail.com>
+ * - Bryan J. Rentoul (Gruvin) <gruvin@gmail.com>
+ *
+ * gruvin9x is based on code named er9x by
+ * Author - Erez Raviv <erezraviv@gmail.com>, which is in turn
+ * was based on the original (and ongoing) project by Thomas Husterer,
+ * th9x -- http://code.google.com/p/th9x/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __GNUC__
+#include <windows.h>
+#define sleep(x) Sleep(x)
+#else
+#include <unistd.h>
+#define sleep(x) usleep(1000*x)
+#endif
+
+#include <ctype.h>
+#include "simpgmspace.h"
+#include "lcd.h"
+#include "er9x.h"
+#include "menus.h"
+
+volatile uint8_t pinb=0, pinc=0xff, pind, pine=0xff, ping=0xff, pinh=0xff, pinj=0xff, pinl=0;
+uint8_t portb, portc, porth=0, dummyport;
+uint16_t dummyport16;
+
+uint8_t heartbeat;
+
+void setSwitch(int8_t swtch)
+{
+  switch (swtch) {
+    case DSW_ID0:
+      ping |=  (1<<INP_G_ID1);  pine &= ~(1<<INP_E_ID2);
+      break;
+    case DSW_ID1:
+      ping &= ~(1<<INP_G_ID1);  pine &= ~(1<<INP_E_ID2);
+      break;
+    case DSW_ID2:
+      ping &= ~(1<<INP_G_ID1);  pine |=  (1<<INP_E_ID2);
+    default:
+      break;
+  }
+}
+
+uint8_t eeprom[EESIZE];
+
+void eeWriteBlockCmp(const void *i_pointer_ram, void *pointer_eeprom, size_t size)
+{
+#if 0
+  printf(" eeWriteBlockCmp(%d %d)", size, (int)pointer_eeprom);
+  for(uint8_t i=0; i<size; i++)
+    printf(" %02X", ((const char*)i_pointer_ram)[i]);
+  printf("\n");fflush(stdout);
+#endif
+
+  memcpy(&eeprom[(int64_t)pointer_eeprom], i_pointer_ram, size);
+}
+
+void eeprom_read_block (void *pointer_ram,
+    const void *pointer_eeprom,
+    size_t size)
+{
+  memcpy(pointer_ram, &eeprom[(uint64_t)pointer_eeprom], size);
+}
+
+
+uint8_t main_thread_running = 0;
+char * main_thread_error = NULL;
+void *main_thread(void *)
+{
+#ifdef SIMU_EXCEPTIONS
+  signal(SIGFPE, sig);
+  signal(SIGSEGV, sig);
+
+  try {
+#endif
+    g_menuStack[0] = menuProc0;
+    // g_menuStack[1] = menuProcModelSelect;
+
+    eeReadAll(); //load general setup and selected model
+
+    if (main_thread_running == 1) {
+      doSplash();
+      checkMem();
+      checkTHR();
+      checkSwitches();
+      checkAlarm();
+      checkWarnings();
+    }
+
+    while (main_thread_running) {
+      perMain();
+      sleep(1/*ms*/);
+    }
+#ifdef SIMU_EXCEPTIONS
+  }
+  catch (...) {
+    main_thread_running = 0;
+  }
+#endif
+  return NULL;
+}
+
+pthread_t main_thread_pid;
+void StartMainThread(bool tests)
+{
+  main_thread_running = (tests ? 1 : 2);
+  pthread_create(&main_thread_pid, NULL, &main_thread, NULL);
+}
+
+void StopMainThread()
+{
+  main_thread_running = 0;
+  pthread_join(main_thread_pid, NULL);
+}
+
+#if 0
+static void EeFsDump(){
+  for(int i=0; i<EESIZE; i++)
+  {
+    printf("%02x ",eeprom[i]);
+    if(i%16 == 15) puts("");
+  }
+  puts("");
+}
+#endif
Index: er9x/simpgmspace.h
===================================================================
--- er9x/simpgmspace.h	(revision 651)
+++ er9x/simpgmspace.h	(working copy)
@@ -1,7 +1,12 @@
 /*
- * Author - Erez Raviv <erezraviv@gmail.com>
+ * Authors (alphabetical order)
+ * - Bertrand Songis <bsongis@gmail.com>
+ * - Bryan J. Rentoul (Gruvin) <gruvin@gmail.com>
  *
- * Based on th9x -> http://code.google.com/p/th9x/
+ * gruvin9x is based on code named er9x by
+ * Author - Erez Raviv <erezraviv@gmail.com>, which is in turn
+ * was based on the original (and ongoing) project by Thomas Husterer,
+ * th9x -- http://code.google.com/p/th9x/
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -14,10 +19,55 @@
  *
  */
 
+#ifndef simpgmspace_h
+#define simpgmspace_h
+
+#ifdef SIMU_EXCEPTIONS
+extern char * main_thread_error;
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <signal.h>
+#if defined(WIN32) || !defined(__GNUC__)
+#define write_backtrace(output)
+#else
+#include <execinfo.h>
+inline void write_backtrace(char *output)
+{
+
+  void *buf[16];
+  char **s;
+  int n = backtrace(buf,16);
+  s = backtrace_symbols(buf, n);
+  if (s) {
+    for(int i=0; i<n; i++)
+      sprintf(output+strlen(output), "%02i: %s\n",i,s[i]);
+  }
+}
+#endif
+void sig(int sgn)
+{
+  main_thread_error = (char *)malloc(2048);
+  sprintf(main_thread_error,"Signal %d caught\n", sgn);
+  write_backtrace(main_thread_error);
+  throw std::exception();
+}
+#define assert(x) do { if (!(x)) { main_thread_error = (char *)malloc(2048); sprintf(main_thread_error, "Assert failed, %s:%d: %s\n", __FILE__, __LINE__, #x); write_backtrace(main_thread_error); throw std::exception(); } } while(0)
+#else
 #include <assert.h>
+#endif
+
 #include <inttypes.h>
 #include <stdio.h>
+#include <pthread.h>
+#include <semaphore.h>
 
+#undef min
+#undef max
+
+#define APM
+#define PGM_P prog_char *
+
 typedef unsigned char prog_uchar;
 typedef const char prog_char;
 typedef const uint16_t prog_uint16_t;
@@ -25,12 +75,15 @@
 typedef const int16_t prog_int16_t;
 typedef const int8_t prog_int8_t;
 
+extern sem_t eeprom_write_sem;
 
+#define loop_until_bit_is_set( port, bitnum) \
+  while ( 0/*! ( (port) & (1 << (bitnum)) )*/ ) ;
 
 #define PROGMEM
 #define pgm_read_byte(address_short) (*(uint8_t*)(address_short))
 #define pgm_read_word(address_short) (*(uint16_t*)(address_short))
-#define pgm_read_adr(address_short) (*(int*)(address_short))
+#define pgm_read_adr(address_short) *address_short
 #define pgm_read_stringP(adr) ((adr))
 #define PSTR(adr) adr
 #define _delay_us(a)
@@ -41,25 +94,94 @@
 
 #define PORTA dummyport
 #define PORTB portb
-#define PORTC dummyport
+#define PORTC portc
+#define PORTD dummyport
+#define PORTE dummyport
+#define PORTF dummyport
 #define PORTG dummyport
-#define DDRA   dummyport
-#define DDRB   dummyport
-#define DDRC   dummyport
+#define PORTH porth
+#define DDRA  dummyport
+#define DDRB  dummyport
+#define DDRC  dummyport
+#define DDRD  dummyport
+#define DDRE  dummyport
+#define DDRF  dummyport
+#define DDRG  dummyport
 #define PINB  ~pinb
+#define PINC  ~pinc
 #define PIND  ~pind
 #define PINE  ~pine
 #define PING  ~ping
+#define PINH  ~pinh
+#define PINJ  ~pinj
+#define PINL  ~pinl
 #define EEMEM
 
-extern unsigned char pinb,pind,pine,ping,portb;
-extern unsigned char dummyport;
-//extern uint16_t anaIn(uint8_t chan);
-//void eeprom_write_block (const void *pointer_ram,
-//                    void *pointer_eeprom,
-//                         size_t size);
+#define UCSR0B dummyport
+#define UDRIE0 dummyport
+#define TXEN0 dummyport
+#define RXEN0 dummyport
+#define DDE0 dummyport
+#define PORTE0 dummyport
+#define RXCIE0 dummyport
+#define OCR0A dummyport
+#define OCR4A dummyport
+#define OCR1B dummyport16
+#define TCCR1A dummyport
+#define COM1B0 dummyport
+
+#define SPDR dummyport
+#define SPSR dummyport
+#define SPIF dummyport
+#define SPCR dummyport
+
+#define TIMSK  dummyport
+#define TIMSK1 dummyport
+
+#define UDR0 dummyport
+#define OCIE1A dummyport
+
+#define OUT_B_LIGHT   7
+#define INP_E_ElevDR  2
+#define INP_E_Trainer 5
+#define INP_E_Gear    4
+#define INP_C_ThrCt   6
+#define INP_C_AileDR  7
+#define INP_E_ID2     6
+
+#define INP_B_KEY_LFT 6
+#define INP_B_KEY_RGT 5
+#define INP_B_KEY_UP  4
+#define INP_B_KEY_DWN 3
+#define INP_B_KEY_EXT 2
+#define INP_B_KEY_MEN 1
+
+#define INP_P_SPARE6    7
+#define INP_P_SPARE5    6
+#define INP_P_KEY_EXT   5
+#define INP_P_KEY_MEN   4
+#define INP_P_KEY_LFT   3
+#define INP_P_KEY_RGT   2
+#define INP_P_KEY_UP    1
+#define INP_P_KEY_DWN   0
+
+extern volatile unsigned char pinb,pinc,pind,pine,ping,pinh,pinj,pinl;
+extern uint8_t portb, portc, porth, dummyport;
+extern uint16_t dummyport16;
+extern uint8_t main_thread_running;
+
+extern void setSwitch(int8_t swtch);
+
+void StartMainThread(bool tests=true);
+void StartEepromThread(const char *filename="eeprom.bin");
+
+extern const char *eepromFile;
 void eeprom_read_block (void *pointer_ram,
                    const void *pointer_eeprom,
                         size_t size);
+
+#undef offsetof
 #define offsetof(st, m) ((size_t) ( (char *)&((st *)(0))->m - (char *)0 ))
 #define wdt_reset()
+
+#endif
Index: er9x/templates.cpp
===================================================================
--- er9x/templates.cpp	(revision 651)
+++ er9x/templates.cpp	(working copy)
@@ -99,7 +99,7 @@
     g_model.customSw[idx-1].v2   = v2;
 }
 
-__attribute__((noinline)) uint8_t convert_mode_helper(uint8_t x)
+uint8_t convert_mode_helper(uint8_t x)
 {
     return pgm_read_byte(modn12x3 + g_eeGeneral.stickMode*4 + (x) - 1) ;
 }
