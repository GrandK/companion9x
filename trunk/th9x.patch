Index: th9x/lcd.cpp
===================================================================
--- th9x/lcd.cpp	(revision 267)
+++ th9x/lcd.cpp	(working copy)
@@ -18,7 +18,9 @@
 
 
 #ifdef SIM
-uint8_t displayBuf[DISPLAY_W*DISPLAY_H/8+DISPLAY_W]; 
+uint8_t displayBuf[DISPLAY_W*DISPLAY_H/8+DISPLAY_W];
+bool lcd_refresh = true;
+uint8_t lcd_buf[DISPLAY_W*DISPLAY_H/8];
 #else
 uint8_t displayBuf[DISPLAY_W*DISPLAY_H/8]; 
 #endif
@@ -63,7 +65,7 @@
 {
   uint8_t   *p  = &displayBuf[ y / 8 * DISPLAY_W + x ];
   bool     inv  = (mode & INVERS) ? true : (mode & BLINK ? BLINK_ON_PHASE : false);
-  uint8_t     i = min(DISPLAY_END-p,(int)w);
+  uint8_t     i = min((int)(DISPLAY_END-p),(int)w);
   if(inv)  for(; i!=0; i--){
     assert(p<DISPLAY_END);
     *p++ ^= 0xff;
@@ -121,7 +123,7 @@
       }
     }
   }else{
-    uint8_t i = min(DISPLAY_END-p,5);
+    uint8_t i = min((int)(DISPLAY_END-p),(int)5);
     if(inv) for(; i!=0; i--) *p++ = ~pgm_read_byte(q++);
     else    for(; i!=0; i--) *p++ =  pgm_read_byte(q++);
     if(p<DISPLAY_END) *p++ = inv ? ~0 : 0;
@@ -389,6 +391,10 @@
 
 void refreshDiplay()
 {
+#ifdef SIM
+  memcpy(lcd_buf, displayBuf, sizeof(lcd_buf));
+  lcd_refresh = true;
+#else
   uint8_t *p=displayBuf; 
   for(uint8_t y=0; y < 8; y++) {
     lcdSendCtl(0x04);
@@ -399,4 +405,5 @@
       p++;
     }
   }
+#endif
 }
Index: th9x/menus.cpp
===================================================================
--- th9x/menus.cpp	(revision 267)
+++ th9x/menus.cpp	(working copy)
@@ -2564,11 +2564,14 @@
   for(uint8_t iHw=0;iHw<7;iHw++){        // calc Sticks
     int16_t v= anaIn(iHw);
     g_sumAna += (uint8_t)v;
+
+#ifndef SIM
     v -= g_eeGeneral.calibMid[iHw];
     v  =  v * (int32_t)RESX /  (max((int16_t)100,
                                     (v>0 ? 
                                      g_eeGeneral.calibSpanPos[iHw] : 
                                      g_eeGeneral.calibSpanNeg[iHw])));
+#endif
 
     if(v <= -RESX) v = -RESX;
     if(v >=  RESX) v =  RESX;
Index: th9x/simpgmspace.cpp
===================================================================
--- th9x/simpgmspace.cpp	(revision 0)
+++ th9x/simpgmspace.cpp	(revision 0)
@@ -0,0 +1,170 @@
+/*
+ * Author	Thomas Husterer <thus1@t-online.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ */
+
+#ifndef __GNUC__
+#include <windows.h>
+#define sleep(x) Sleep(x)
+#else
+#include <unistd.h>
+#define sleep(x) usleep(1000*x)
+#endif
+
+#include "simpgmspace.h"
+#include "lcd.h"
+#include "th9x.h"
+#include <ctype.h>
+
+volatile unsigned char pinb,portb,pinc,pind,pine,ping=0xff;
+unsigned char dummyport;
+char g_title[80];
+const char *eepromFile = NULL;
+uint8_t eeprom[EESIZE];
+
+extern unsigned char displayBuf[DISPLAY_W*DISPLAY_H/8+DISPLAY_W];
+
+void lcd_img_f(int ofs,unsigned char x,unsigned char y,int i_w,int i_h)
+{
+  
+  prog_uchar  buf[1000];
+  FILE *fp=fopen("../th9x-orig/flash.bin", "r");
+  fseek(fp,ofs,SEEK_SET);
+  fread(buf,1,i_h/8*i_w,fp);
+  fclose(fp);
+  prog_uchar  *q = buf;//+0x10e*3+0x10;
+  int h=i_h;
+  while(h>0){
+    int w=i_w;
+    unsigned char *p = &displayBuf[ y / 8 * DISPLAY_W + x ];
+    while(w>0){
+      *p = pgm_read_byte(q); p++; q++;
+      w--;
+    }
+    h-=8;
+    y+=8;
+  }
+}
+
+
+FILE *fp = 0;
+
+void eeWriteBlockCmp(const void *i_pointer_ram, void *pointer_eeprom, size_t size)
+{
+  if (eepromFile) {
+    if(!fp) fp = fopen(eepromFile, "r+");
+    long ofs = (long) pointer_eeprom;
+    const char* pointer_ram= (const char*)i_pointer_ram;
+    //printf("eeWr p=%10p blk%3d ofs=%2d l=%d",pointer_ram,
+    //       (int)pointer_eeprom/16,
+    //       (int)pointer_eeprom%16,
+    //       (int)size);
+    while(size){
+      if(fseek(fp, ofs , SEEK_SET)==-1) perror("error in seek");
+      char buf[1];
+      fread(buf, 1, 1,fp);
+
+      if(buf[0] !=  pointer_ram[0]){
+        //printf("X");
+        g_tmr10ms++;
+        if(fseek(fp, ofs , SEEK_SET)==-1) perror("error in seek");
+        fwrite(pointer_ram, 1, 1,fp);
+      }else{
+        //printf(".");
+      }
+
+      size--;
+      ofs++;
+      (const char*)pointer_ram++;
+    }
+    //fclose(fp);
+    //puts("");
+  }
+  else {
+    memcpy(&eeprom[(int64_t)pointer_eeprom], i_pointer_ram, size);
+  }
+}
+void eeprom_write_blockxx (const void *pointer_ram,
+                    void *pointer_eeprom,
+                    size_t size)
+{
+  printf("eeprom_write_block p=%p ofs=%d l=%2d\n",pointer_ram,(long int)pointer_eeprom,(long int)size);
+  //  FILE *fp=fopen(eepromFile, "r+");
+  if(!fp) fp = fopen(eepromFile, "r+");
+  if(fseek(fp, (long) pointer_eeprom, SEEK_SET)==-1) perror("error in seek");
+  fwrite(pointer_ram, size, 1,fp);
+  //fclose(fp);
+}
+
+void eeprom_read_block (void *pointer_ram,
+                   const void *pointer_eeprom,
+                   size_t size)
+{
+  if (eepromFile) {
+    //FILE *fp=fopen(eepromFile, "r");
+    if(!fp) fp = fopen(eepromFile, "r+");
+    if(fseek(fp, (long) pointer_eeprom, SEEK_SET)==-1) perror("error in seek");
+    fread(pointer_ram, size, 1, fp);
+    //fclose(fp);
+  }
+  else {
+    memcpy(pointer_ram, &eeprom[(uint64_t)pointer_eeprom], size);
+  }
+}
+
+uint8_t main_thread_running = 0;
+char * main_thread_error = NULL;
+void *main_thread(void *)
+{
+#ifdef SIMU_EXCEPTIONS
+  signal(SIGFPE, sig);
+  signal(SIGSEGV, sig);
+
+  try {
+#endif
+    eeReadAll(); //load general setup and selected model
+
+    if (main_thread_running == 1) {
+      checkMem();  //enough eeprom free?
+      checkTHR();
+      checkSwitches(); //must be last
+    }
+
+    chainMenu(menuProc0); //call evt_entry
+
+    while (main_thread_running) {
+      perMain();
+      sleep(1/*ms*/);
+    }
+#ifdef SIMU_EXCEPTIONS
+  }
+  catch (...) {
+    main_thread_running = 0;
+  }
+#endif
+
+  return NULL;
+}
+
+pthread_t main_thread_pid;
+void StartMainThread(bool tests)
+{
+  main_thread_running = (tests ? 1 : 2);
+  pthread_create(&main_thread_pid, NULL, &main_thread, NULL);
+}
+
+void StopMainThread()
+{
+  main_thread_running = 0;
+  pthread_join(main_thread_pid, NULL);
+}
+
Index: th9x/simpgmspace.h
===================================================================
--- th9x/simpgmspace.h	(revision 267)
+++ th9x/simpgmspace.h	(working copy)
@@ -12,9 +12,48 @@
 
  */
 
+#ifndef simpgmspace_h
+#define simpgmspace_h
+
+#ifdef SIMU_EXCEPTIONS
+extern char * main_thread_error;
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#if defined(WIN32) || !defined(__GNUC__)
+#define write_backtrace(output)
+#else
+#include <execinfo.h>
+#include <string.h>
+inline void write_backtrace(char *output)
+{
+
+  void *buf[16];
+  char **s;
+  int n = backtrace(buf,16);
+  s = backtrace_symbols(buf, n);
+  if (s) {
+    for(int i=0; i<n; i++)
+      sprintf(output+strlen(output), "%02i: %s\n",i,s[i]);
+  }
+}
+#endif
+void sig(int sgn)
+{
+  main_thread_error = (char *)malloc(2048);
+  sprintf(main_thread_error,"Signal %d caught\n", sgn);
+  write_backtrace(main_thread_error);
+  throw std::exception();
+}
+#define assert(x) do { if (!(x)) { main_thread_error = (char *)malloc(2048); sprintf(main_thread_error, "Assert failed, %s:%d: %s\n", __FILE__, __LINE__, #x); write_backtrace(main_thread_error); throw std::exception(); } } while(0)
+#else
 #include <assert.h>
+#endif
+
 #include <inttypes.h>
 #include <stdio.h>
+#include <pthread.h>
+#include <semaphore.h>
 
 typedef unsigned char prog_uchar;
 typedef const char prog_char;
@@ -62,5 +101,8 @@
 void eeprom_read_block (void *pointer_ram,
                    const void *pointer_eeprom,
                         size_t size);
+#undef offsetof
 #define offsetof(st, m) ((size_t) ( (char *)&((st *)(0))->m - (char *)0 ))
 #define wdt_reset()
+
+#endif
Index: th9x/simu.cpp
===================================================================
--- th9x/simu.cpp	(revision 267)
+++ th9x/simu.cpp	(working copy)
@@ -23,93 +23,6 @@
 #include <time.h>
 #include <ctype.h>
 
-
-volatile unsigned char pinb,portb,pinc,pind,pine,ping;
-unsigned char dummyport;
-char g_title[80];
-const char *eepromFile = "eeprom.bin";
-
-extern unsigned char displayBuf[DISPLAY_W*DISPLAY_H/8+DISPLAY_W];
-
-void lcd_img_f(int ofs,unsigned char x,unsigned char y,int i_w,int i_h)
-{
-  
-  prog_uchar  buf[1000];
-  FILE *fp=fopen("../th9x-orig/flash.bin", "r");
-  fseek(fp,ofs,SEEK_SET);
-  fread(buf,1,i_h/8*i_w,fp);
-  fclose(fp);
-  prog_uchar  *q = buf;//+0x10e*3+0x10;
-  int h=i_h;
-  while(h>0){
-    int w=i_w;
-    unsigned char *p = &displayBuf[ y / 8 * DISPLAY_W + x ];
-    while(w>0){
-      *p = pgm_read_byte(q); p++; q++;
-      w--;
-    }
-    h-=8;
-    y+=8;
-  }
-}
-
-
-FILE *fp = 0;
-
-void eeWriteBlockCmp(const void *i_pointer_ram, void *pointer_eeprom, size_t size)
-{
-  if(!fp) fp = fopen(eepromFile, "r+");
-  long ofs = (long) pointer_eeprom;
-  const char* pointer_ram= (const char*)i_pointer_ram;
-  //printf("eeWr p=%10p blk%3d ofs=%2d l=%d",pointer_ram,
-  //       (int)pointer_eeprom/16,
-  //       (int)pointer_eeprom%16,
-  //       (int)size);
-  while(size){
-    if(fseek(fp, ofs , SEEK_SET)==-1) perror("error in seek");
-    char buf[1];
-    fread(buf, 1, 1,fp);
-
-    if(buf[0] !=  pointer_ram[0]){
-      //printf("X");
-      g_tmr10ms++;
-      if(fseek(fp, ofs , SEEK_SET)==-1) perror("error in seek");
-      fwrite(pointer_ram, 1, 1,fp);
-    }else{
-      //printf(".");
-    }
-
-    size--;
-    ofs++;
-    (const char*)pointer_ram++;
-  }
-  //fclose(fp);
-  //puts("");
-}
-void eeprom_write_blockxx (const void *pointer_ram,
-                    void *pointer_eeprom,
-                    size_t size)
-{
-  printf("eeprom_write_block p=%p ofs=%d l=%2d\n",pointer_ram,(int)pointer_eeprom,(int)size);
-  //  FILE *fp=fopen(eepromFile, "r+");
-  if(!fp) fp = fopen(eepromFile, "r+");
-  if(fseek(fp, (long) pointer_eeprom, SEEK_SET)==-1) perror("error in seek");
-  fwrite(pointer_ram, size, 1,fp);
-  //fclose(fp);
-}
-
-void eeprom_read_block (void *pointer_ram,
-                   const void *pointer_eeprom,
-                   size_t size)
-{
-  //FILE *fp=fopen(eepromFile, "r");
-  if(!fp) fp = fopen(eepromFile, "r+");
-  if(fseek(fp, (long) pointer_eeprom, SEEK_SET)==-1) perror("error in seek");
-  fread(pointer_ram, size, 1, fp);
-  //fclose(fp);
-}
-
-
 #define W  DISPLAY_W
 #define H  DISPLAY_H
 #define W2 W*2
@@ -448,10 +361,7 @@
 
 int main(int argc,char **argv)
 {
-  
-  if(argc>=2){
-    eepromFile = argv[1];
-  }
+  eepromFile = (argc>=2 ? argv[1] : "eeprom.bin");
   printf("eeprom = %s\n",eepromFile);
 
   pine = 0xff & ~(1<<INP_E_ID2);// & ~(1<<INP_E_ElevDR);
Index: th9x/th9x.cpp
===================================================================
--- th9x/th9x.cpp	(revision 267)
+++ th9x/th9x.cpp	(working copy)
@@ -511,10 +511,12 @@
     perChecks(); //check light switch in timerint, issue 51
 
     if(IS_KEY_BREAK(getEvent()))   return false;  //wait for key release
+    /* TODO !!!!
 #ifdef SIM
 void doFxEvents();
     doFxEvents();
-#endif    
+#endif
+*/
   } while(! (mode&1));
   return true;
 }
